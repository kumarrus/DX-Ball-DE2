//cycles for 50MHz for the ball_'s position to update (i.e. ball_X = ball_X + ball_Vx)
param ball_CyclesToUpdate = 5000000; //at most, 10 px/sec ---------------------------  (50,000,000 cycles/sec) / (10 px/sec) ------------> 1 px per 5,000,000 cycles   
param paddle_CyclesToMove = 1010101;
param ball_Radius = 8; // to big? radius 2 should be fine.. (gives a 4x4 img)
param maxX = 159;
param maxY = 120;
param paddle_Length = 20;


/* PADDLE INFORMATION */
      
      
/* ball_ INFORMATION */
      // right => increase x
      // down => increase y
reg [7:0] ball_X;
reg [6:0] ball_Y;
reg ball_Left, ball_Right; //always inverse of each other
reg ball_Up, ball_Down; //always inverse of each other

//INITIAL SETTINGS
initial begin
  ball_Vx = 1;
  ball_Vy = 1;
  ball_X = 20;
  ball_Y = 95;
  ball_Right = 1;
  ball_Down = 1;
end

//should work something like this ---> done , implemented something like this in my code.. its under module "plotter".... but this takes into account only the edges of the screen..
// we need to have somthing that takes care of the paddle collision

reg [25:0] counter;
always @(posedge clock) begin

  // <------------- UPDATE ball_ ---------->
  if (counter % ball_CyclesToUpdate == 0) begin
    ball_X <= ball_X - ball_Left + ball_Right;
    ball_Y <= ball_Y + ball_Down - ball_Up;
    
    // <------------ ball_ COLLISION ---------------> 
    // <- Does not account when the ball_ hits the corners of the paddle (needs more calculations)
    // <- Does not account when ball_ hits bottom and the paddle isn't there (game over condition)
    
    //ball_ hits left (x is at px 0) /right edge of screen (x + 2r is at rightmost px)
    if (ball_X == 'd0 || (ball_X + 'd2*ball_Radius) >= maxX ) begin //SCREEN COLLISION IN X
      ball_Left <= ~ball_Left;
      ball_Right <= ~ball_Right;
    end else if (ball_Y == 'd0) begin //SCREEN COLLISION ON TOP OF SCREEN
      ball_Up <= ~ball_Up;
      ball_Down <= ~ball_Down;
    end else if ((ball_Y + 'd2*ball_Radius) == maxY) begin //SCREEN COLLISION ON BOTTOM OF SCREEN
      if (((ball_X + ball_Radius) > paddleX) && ((ball_X + ball_Radius) < (paddleX + paddleLength)) begin
            ball_Up <= ~ball_Up;
            ball_Down <= ~ball_Down;           
      end 
    end
  end //end update ball_
end //end always posedge clk block
