//cycles for 50MHz for the ball's position to update (i.e. ballX = ballX + ballVx)
param ballCyclesToUpdate = 5000000; //at most, 10 px/sec ---------------------------  (50,000,000 cycles/sec) / (10 px/sec) ------------> 1 px per 5,000,000 cycles   
param ballRadius = 8; -- to big? radius 2 should be fine.. (gives a 4x4 img)
param maxX = 159;
param maxY = 120;
param paddleLength = 20;


      
      
//ball's position (top left corner)
reg [7:0] ballX;
reg [6:0] ballY;
//ball's speed in x and y direction
//Vx + => move right
//Vy + => move down
reg ballLeft, ballRight, ballUp, ballDown; //wrt screen

//INITIAL SETTINGS
initial begin
  ballVx = 1;
  ballVy = 1;
  ballX = 20;
  ballY = 95;
end

//should work something like this ---> done , implemented something like this in my code.. its under module "plotter".... but this takes into account only the edges of the screen..
// we need to have somthing that takes care of the paddle collision

reg [25:0] counter;
always @(posedge clock) begin

  // <------------- UPDATE BALL ---------->
  if (counter % ballCyclesToUpdate == 0) begin
    ballX <= ballX - ballLeft + ballRight;
    ballY <= ballY + ballDown - ballUp;
    
    if (paddleLeft)
      paddleX <= paddleX - 1;
    else if (paddleRight)
      paddleX <= paddleX + 1;
    
    
    // <------------ COLLISION ---------------> 
    // <- Does not account when the ball hits the corners of the paddle (needs more calculations)
    // <- Does not account when ball hits bottom and the paddle isn't there (game over condition)
    
    //Ball hits left (x is at px 0) /right edge of screen (x + 2r is at rightmost px)
    if (ballX == 'd0 || (ballX + 'd2*ballRadius) >= maxX ) begin //SCREEN COLLISION IN X
      ballLeft <= ~ballLeft;
      ballRight <= ~ballRight;
    end else if (ballY == 'd0) begin //SCREEN COLLISION ON TOP OF SCREEN
      ballUp <= ~ballUp;
      ballDown <= ~ballDown;
    end else if ((ballY + 'd2*ballRadius) == maxY) begin //SCREEN COLLISION ON BOTTOM OF SCREEN
      if (((ballX + ballRadius) > paddleX) && ((ballX + ballRadius) < (paddleX + paddleLength)) begin
            ballUp <= ~ballUp;
            ballDown <= ~ballDown;           
      end 
    end
  end //end update ball

end //end always posedge clk block
